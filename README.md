# Реализация реактивных потоков с поддержкой многопоточности и основных операторов преобразования

## Описание проекта
Данный проект представляет собой реализацию библиотеки для работы с реактивными потоками данных в Java. Библиотека поддерживает основные операторы преобразования данных, такие как `map`, `filter` и `flatMap`, а также обеспечивает управление потоками через различные планировщики (Schedulers) и механизм отмены подписок (Disposable).

## Архитектура системы

Проект состоит из нескольких ключевых компонентов:

1. **Observable<T>**: Центральный класс для создания потоков данных. Он позволяет создавать и управлять потоками, а также обрабатывать данные с помощью операторов.

   Пример создания потока данных:
   ```java
   Observable.create(emitter -> {
       emitter.onNext(data);
       emitter.onComplete();
   });
   ```

2. **Observer<T>**: Интерфейс для обработки данных, ошибок и завершения потока. Подписчики реализуют этот интерфейс для получения уведомлений о событиях.

3. **Disposable**: Интерфейс, который предоставляет методы для отмены подписки на поток данных. Это позволяет управлять жизненным циклом подписки и освобождать ресурсы.

4. **Schedulers**: Компоненты для управления потоками выполнения. Позволяют задавать, в каком потоке будет выполняться работа с данными. Существует несколько типов планировщиков, каждый из которых оптимизирован под разные сценарии использования.

5. **Операторы**: Классы, реализующие основные операторы преобразования данных. Они позволяют изменять, фильтровать и комбинировать данные в потоках.

## Принципы работы Schedulers

Schedulers управляют потоками выполнения и позволяют разработчикам выбирать, где должны выполняться операции с данными. В проекте реализованы следующие типы планировщиков:

- **IOThreadScheduler**: Использует `CachedThreadPool` для выполнения операций ввода-вывода. Подходит для задач, связанных с сетью или файловой системой, где время ожидания может быть значительным.

- **ComputationScheduler**: Использует `FixedThreadPool`, количество потоков в котором соответствует количеству доступных процессорных ядер. Оптимален для выполнения вычислительно интенсивных задач.

- **SingleThreadScheduler**: Использует `SingleThreadExecutor`, что позволяет выполнять задачи последовательно в одном потоке. Подходит для сценариев, где необходимо избежать конкуренции за ресурсы.

## Процесс тестирования и основные сценарии

Тестирование библиотеки включает в себя проверку основных сценариев использования и обработки ошибок. В проекте реализованы следующие тесты:

1. **Основной поток данных**: Проверка корректности передачи данных от источника к подписчику.
2. **Оператор map**: Проверка преобразования данных с помощью оператора `map`.
3. **Обработка ошибок**: Проверка правильного реагирования на ошибки в потоке данных.
4. **Планирование потоков**: Проверка корректности работы с различными планировщиками (Schedulers) и переключения между потоками.
5. **Отмена подписки**: Проверка механизма отмены подписки и освобождения ресурсов.

Тесты реализованы с использованием JUnit и Mockito, что позволяет имитировать поведение зависимостей и проверять взаимодействие между компонентами.

## Примеры использования библиотеки

### Пример 1: Создание и подписка на поток данных
```java
Observable.<String>create(emitter -> {
    emitter.onNext("Hello");
    emitter.onNext("World");
    emitter.onComplete();
}).subscribe(new Observer<String>() {
    @Override
    public void onNext(String item) {
        System.out.println(item);
    }

    @Override
    public void onError(Throwable t) {
        System.err.println("Error: " + t.getMessage());
    }

    @Override
    public void onComplete() {
        System.out.println("Done!");
    }
});
```

### Пример 2: Использование операторов
```java
Observable.just("apple", "banana", "cherry")
    .filter(s -> s.length() > 5)
    .map(String::toUpperCase)
    .subscribe(new Observer<String>() {
        @Override
        public void onNext(String item) {
            System.out.println(item);
        }

        @Override
        public void onError(Throwable t) {
            System.err.println("Error: " + t.getMessage());
        }

        @Override
        public void onComplete() {
            System.out.println("Done!");
        }
    });
```

### Пример 3: Работа с планировщиками
```java
Observable.just(1)
    .subscribeOn(new IOThreadScheduler())
    .observeOn(new SingleThreadScheduler())
    .subscribe(new Observer<Integer>() {
        @Override
        public void onNext(Integer item) {
            System.out.println("Received: " + item);
        }

        @Override
        public void onError(Throwable t) {
            System.err.println("Error: " + t.getMessage());
        }

        @Override
        public void onComplete() {
            System.out.println("Done!");
        }
    });
```

## Заключение

В данной библиотеке реализована основа для работы с реактивными потоками данных в Java. Она предоставляет мощные инструменты для обработки данных, управления потоками и обработки ошибок, что делает её полезной для создания асинхронных и отзывчивых приложений.